// Generated by CoffeeScript 1.9.3

/*
 @author Raoul Harel
 @license The MIT license (LICENSE.txt)
 @copyright 2015 Raoul Harel
 @url rharel/node-gol-hashlife on GitHub
 */

(function() {
  var Library, alive, dead, gol, should;

  gol = require('../lib/gol');

  Library = gol.Library;

  dead = gol.dead;

  alive = gol.alive;

  should = require('should');

  describe('library unit', function() {
    describe('initialization', function() {
      var lib;
      lib = new Library;
      return it('should have size 0', function() {
        return lib.size().should.be.equal(0);
      });
    });
    describe('id', function() {
      var lib;
      lib = new Library;
      it('should increment id for each new cell', function() {
        var a, b, c;
        a = lib.get(dead, dead, dead, dead);
        b = lib.get(dead, dead, dead, alive);
        c = lib.get(dead, dead, alive, alive);
        b.id.should.be.equal(a.id + 1);
        return c.id.should.be.equal(b.id + 1);
      });
      return it('should have size 2', function() {
        return lib.size().should.be.equal(3);
      });
    });
    describe('hash', function() {
      return it('should equal the binary representation for level 1 cells', function() {
        var a, b, c, d, i, j, k, l, len, len1, len2, len3, ref, ref1, ref2, ref3, result;
        result = [];
        ref = [dead, alive];
        for (i = 0, len = ref.length; i < len; i++) {
          d = ref[i];
          ref1 = [dead, alive];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            c = ref1[j];
            ref2 = [dead, alive];
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              b = ref2[k];
              ref3 = [dead, alive];
              for (l = 0, len3 = ref3.length; l < len3; l++) {
                a = ref3[l];
                result.push(Library._hash(a, b, c, d));
              }
            }
          }
        }
        return result.sort().should.be.eql([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15].map(function(x) {
          return x.toString();
        }).sort());
      });
    });
    return describe('lookup', function() {
      var lib;
      lib = new Library;
      return it('should return cached cell if it exists', function() {
        var a, b;
        a = lib.get(dead, dead, dead, dead);
        b = lib.get(dead, dead, dead, dead);
        return b.should.be.equal(a);
      });
    });
  });

}).call(this);

//# sourceMappingURL=library_unit.test.js.map
