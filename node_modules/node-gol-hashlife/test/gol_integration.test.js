// Generated by CoffeeScript 1.9.3

/*
 @author Raoul Harel
 @license The MIT license (LICENSE.txt)
 @copyright 2015 Raoul Harel
 @url rharel/node-gol-hashlife on GitHub
 */

(function() {
  var Simulation, alive, by_x_then_y, dead, from_rle, gol, helpers, should;

  gol = require('../lib/gol');

  Simulation = gol.Simulation;

  dead = gol.dead;

  alive = gol.alive;

  helpers = require('./helpers.test');

  by_x_then_y = helpers.by_x_then_y;

  from_rle = helpers.from_rle;

  should = require('should');

  describe('gol integration', function() {
    describe('initialization', function() {
      var sim;
      sim = new Simulation(3);
      return it('should have 2^3 size', function() {
        return sim.size().should.be.equal(8);
      });
    });
    describe('setting cell values', function() {
      var sim;
      sim = null;
      it('should save the value of a single cell', function() {
        sim = new Simulation(2);
        sim.set(0, 0);
        return sim._root.to_array().should.be.eql([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      });
      it('should save the value of multiple cells (4x4)', function() {
        var i, j, len, p, ref;
        sim = new Simulation(2);
        ref = [[0, 0], [1, -1], [1, -2], [0, -2], [-1, -2]];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          p = ref[i];
          sim.set(p[0], p[1]);
        }
        return sim._root.to_array().should.be.eql([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1]);
      });
      return it('should save the value of multiple cells (8x8)', function() {
        var i, j, len, p, ref;
        sim = new Simulation(3);
        ref = [[0, 0], [1, -1], [1, -2], [0, -2], [-1, -2]];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          p = ref[i];
          sim.set(p[0], p[1]);
        }
        return sim._root.to_array().should.be.eql([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      });
    });
    return describe('getting cell values', function() {
      it('should return nothing for empty universe', function() {
        var sim;
        sim = new Simulation(2);
        return sim.get(-1).length.should.be.equal(0);
      });
      describe('tracking the glider pattern', function() {

        /*
          t = 0      t = 1      t = 2
          -----      -----      -----
          0 1 0 0    0 0 0 0    0 0 0 0
          0 0 1 0    1 0 1 0    0 0 1 0
          1 1 1 0    0 1 1 0    1 0 1 0
          0 0 0 0    0 1 0 0    0 1 1 0
         */
        var gen0, gen1, gen2, i, j, len, p, sim;
        gen0 = [
          {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: -1,
            y: 1
          }, {
            x: 0,
            y: -1
          }, {
            x: 0,
            y: 0
          }
        ];
        gen1 = [
          {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: -2
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 0,
            y: 0
          }
        ];
        gen2 = [
          {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 0,
            y: -1
          }, {
            x: 0,
            y: 0
          }
        ];
        sim = new Simulation(3);
        for (i = j = 0, len = gen0.length; j < len; i = ++j) {
          p = gen0[i];
          sim.set(p.x, p.y);
        }
        it('should match data at t = 0', function() {
          return sim.get(-1).sort(by_x_then_y).should.be.eql(gen0);
        });
        it('should match data at t = 1', function() {
          return sim.get(0).sort(by_x_then_y).should.be.eql(gen1);
        });
        return it('should match data at t = 2', function() {
          return sim.get(1).sort(by_x_then_y).should.be.eql(gen2);
        });
      });
      return describe('tracking the \'figure eight\' pattern', function() {
        var f, gen, gen0, gen_rle, i, j, k, len, len1, p, results, sim, t;
        gen_rle = [
          {
            w: 6,
            h: 6,
            data: '3o$3o$3o$3b3o$3b3o$3b3o!'
          }, {
            w: 8,
            h: 8,
            data: '2bo$bobo$o3bo$bo3bo$2bo3bo$3bo3bo$4bobo$5bo!'
          }, {
            w: 8,
            h: 8,
            data: '2bo$b3o$3obo$bo3bo$2bo3bo$3bob3o$4b3o$5bo!'
          }, {
            w: 10,
            h: 10,
            data: '3bo$2b2o$bob2o$3o2bo$2bobobo' + '$3bobobo$4bo2b3o$5b2obo$6b2o$6bo!'
          }, {
            w: 6,
            h: 6,
            data: '3o$3o$3o$3b3o$3b3o$3b3o!'
          }
        ];
        gen = gen_rle.map(function(g) {
          return from_rle(-g.w / 2, -g.h / 2, g.w, g.h, g.data);
        });
        gen0 = gen[0];
        gen = gen.slice(1, gen.length);
        sim = new Simulation(5);
        for (i = j = 0, len = gen0.length; j < len; i = ++j) {
          p = gen0[i];
          sim.set(p.x, p.y);
        }
        it('should match data at t = 0', function() {
          return sim.get(-1).sort(by_x_then_y).should.be.eql(gen0.sort(by_x_then_y));
        });
        results = [];
        for (t = k = 0, len1 = gen.length; k < len1; t = ++k) {
          f = gen[t];
          results.push((function(sim, f, t) {
            return it('should match data at t = 2^' + t, function() {
              return sim.get(t).sort(by_x_then_y).should.be.eql(f.sort(by_x_then_y));
            });
          })(sim, f, t));
        }
        return results;
      });
    });
  });

}).call(this);

//# sourceMappingURL=gol_integration.test.js.map
