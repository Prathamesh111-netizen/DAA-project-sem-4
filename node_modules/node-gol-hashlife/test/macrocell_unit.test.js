// Generated by CoffeeScript 1.9.3

/*
 @author Raoul Harel
 @license The MIT license (LICENSE.txt)
 @copyright 2015 Raoul Harel
 @url rharel/node-gol-hashlife on GitHub
 */

(function() {
  var MacroCell, alive, dead, gol, it_should_flush_to, should, should_have_children;

  gol = require('../lib/gol');

  MacroCell = gol.MacroCell;

  dead = gol.dead;

  alive = gol.alive;

  should = require('should');

  should_have_children = function(cell, nw, ne, sw, se) {
    cell.nw.should.be.equal(nw);
    cell.ne.should.be.equal(ne);
    cell.sw.should.be.equal(sw);
    return cell.se.should.be.equal(se);
  };

  it_should_flush_to = function(cell, expected) {
    return it('should flush to...', function() {
      return cell.to_array().should.be.eql(expected);
    });
  };

  describe('macro-cell unit', function() {
    describe('default initialization', function() {
      describe('level 1', function() {
        var m;
        m = new MacroCell;
        it('should be level 1', function() {
          return m.level().should.be.equal(1);
        });
        it('should have dead chlidren', function() {
          return should_have_children(m, dead, dead, dead, dead);
        });
        return it('should have 0 living count', function() {
          return m.population().should.be.equal(0);
        });
      });
      return describe('level 2', function() {
        var m, ne, nw, se, sw;
        nw = new MacroCell;
        ne = new MacroCell;
        sw = new MacroCell;
        se = new MacroCell;
        m = new MacroCell(nw, ne, sw, se);
        it('should be level 2', function() {
          return m.level().should.be.equal(2);
        });
        it('should have 0 living count', function() {
          return m.population().should.be.equal(0);
        });
        return it('should be dead', function() {
          should_have_children(m.nw, dead, dead, dead, dead);
          should_have_children(m.ne, dead, dead, dead, dead);
          should_have_children(m.sw, dead, dead, dead, dead);
          return should_have_children(m.se, dead, dead, dead, dead);
        });
      });
    });
    describe('initialization from array', function() {
      describe('level 1', function() {
        var m;
        m = MacroCell.from_array([dead, alive, alive, dead]);
        it('should be level 1', function() {
          return m.level().should.be.equal(1);
        });
        it('should match the array', function() {
          return should_have_children(m, dead, alive, alive, dead);
        });
        return it('should have 2 living count', function() {
          return m.population().should.be.equal(2);
        });
      });
      describe('level 2', function() {
        var m;
        m = MacroCell.from_array([1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1]);
        it('should be level 2', function() {
          return m.level().should.be.equal(2);
        });
        it('should have 4 living count', function() {
          return m.population().should.be.equal(4);
        });
        return it('should match the array', function() {
          should_have_children(m.nw, alive, dead, dead, dead);
          should_have_children(m.ne, dead, alive, dead, dead);
          should_have_children(m.sw, dead, dead, alive, dead);
          return should_have_children(m.se, dead, dead, dead, alive);
        });
      });
      return describe('level 3', function() {
        var a, m;
        a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1];
        m = MacroCell.from_array(a);
        it('should be level 3', function() {
          return m.level().should.be.equal(3);
        });
        it('should have 20 living count', function() {
          return m.population().should.be.equal(20);
        });
        return it('should match the array', function() {
          should_have_children(m.nw.nw, dead, dead, dead, alive);
          should_have_children(m.nw.ne, dead, dead, alive, dead);
          should_have_children(m.nw.sw, dead, dead, alive, alive);
          should_have_children(m.nw.se, dead, alive, dead, dead);
          should_have_children(m.ne.nw, dead, dead, dead, alive);
          should_have_children(m.ne.ne, dead, dead, alive, dead);
          should_have_children(m.ne.sw, dead, alive, dead, dead);
          should_have_children(m.ne.se, dead, dead, alive, alive);
          should_have_children(m.sw.nw, dead, dead, alive, dead);
          should_have_children(m.sw.ne, dead, dead, dead, alive);
          should_have_children(m.sw.sw, dead, dead, alive, alive);
          should_have_children(m.sw.se, dead, alive, dead, dead);
          should_have_children(m.se.nw, dead, alive, dead, dead);
          should_have_children(m.se.ne, dead, dead, alive, dead);
          should_have_children(m.se.sw, dead, dead, alive, alive);
          return should_have_children(m.se.se, dead, dead, dead, alive);
        });
      });
    });
    describe('conversion to array', function() {
      describe('level 1', function() {
        var a, b, c, d, j, len, ref, results, test_case;
        test_case = function(name, nw, ne, sw, se) {
          var expected, m;
          expected = [nw, ne, sw, se];
          m = new MacroCell(nw, ne, sw, se);
          return it(name, function() {
            return m.to_array().should.be.eql(expected);
          });
        };
        ref = [dead, alive];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          d = ref[j];
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = [dead, alive];
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              c = ref1[k];
              results1.push((function() {
                var l, len2, ref2, results2;
                ref2 = [dead, alive];
                results2 = [];
                for (l = 0, len2 = ref2.length; l < len2; l++) {
                  b = ref2[l];
                  results2.push((function() {
                    var len3, n, ref3, results3;
                    ref3 = [dead, alive];
                    results3 = [];
                    for (n = 0, len3 = ref3.length; n < len3; n++) {
                      a = ref3[n];
                      results3.push(test_case("should flush [" + a + ", " + b + ", " + c + ", " + d + "]", a, b, c, d));
                    }
                    return results3;
                  })());
                }
                return results2;
              })());
            }
            return results1;
          })());
        }
        return results;
      });
      describe('level 2', function() {
        var m, ne, nw, se, sw;
        nw = new MacroCell(dead, dead, dead, alive);
        ne = new MacroCell(dead, dead, alive, dead);
        sw = new MacroCell(dead, dead, alive, alive);
        se = new MacroCell(dead, alive, dead, dead);
        m = new MacroCell(nw, ne, sw, se);
        return it_should_flush_to(m, [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0]);
      });
      return describe('level 3', function() {
        var a, b, c, d, m, m1, m2, m3, m4;
        a = new MacroCell(dead, dead, dead, alive);
        b = new MacroCell(dead, dead, alive, dead);
        c = new MacroCell(dead, dead, alive, alive);
        d = new MacroCell(dead, alive, dead, dead);
        m1 = new MacroCell(a, b, c, d);
        m2 = new MacroCell(a, b, d, c);
        m3 = new MacroCell(b, a, c, d);
        m4 = new MacroCell(d, b, c, a);
        m = new MacroCell(m1, m2, m3, m4);
        return it_should_flush_to(m, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1]);
      });
    });
    return describe('computing result', function() {
      describe('level 2', function() {
        var i, j, results, test_case;
        test_case = function(name, nNeighbours, expected_state) {
          return describe(name, function() {
            var m, ne, nw, r, se, sw;
            nw = new MacroCell(nNeighbours > 0, nNeighbours > 1, nNeighbours > 2, alive);
            ne = new MacroCell(nNeighbours > 3, dead, nNeighbours > 4, dead);
            sw = new MacroCell(nNeighbours > 5, nNeighbours > 6, dead, dead);
            se = new MacroCell(nNeighbours > 7, dead, dead, dead);
            m = new MacroCell(nw, ne, sw, se);
            r = m.future();
            return it("should be " + (expected_state ? 'alive' : 'dead'), function() {
              return r.nw.should.be.equal(expected_state);
            });
          });
        };
        results = [];
        for (i = j = 0; j <= 8; i = ++j) {
          results.push(test_case("living cell with " + i + " living neighbours", i, i < 2 || i > 3 ? dead : alive));
        }
        return results;
      });
      return describe('level 3', function() {
        describe('intermediate children', function() {
          var m, ne, nw, se, sw;
          nw = new MacroCell;
          ne = new MacroCell;
          sw = new MacroCell;
          se = new MacroCell;
          m = new MacroCell(nw, ne, sw, se);
          it('should have north composed of [nw.east, ne.west]', function() {
            return should_have_children(m.n, nw.ne, ne.nw, nw.se, ne.sw);
          });
          it('should have south composed of [sw.east, se.west]', function() {
            return should_have_children(m.s, sw.ne, se.nw, sw.se, se.sw);
          });
          it('should have west composed of [nw.south, sw.north]', function() {
            return should_have_children(m.w, nw.sw, nw.se, sw.nw, sw.ne);
          });
          it('should have east composed of [ne.south, se.north]', function() {
            return should_have_children(m.e, ne.sw, ne.se, se.nw, se.ne);
          });
          return it('should have center composed of [nw.se, ne.sw, sw.ne, se.nw]', function() {
            return should_have_children(m.c, nw.se, ne.sw, sw.ne, se.nw);
          });
        });
        return describe('future', function() {
          var m, r;
          m = MacroCell.from_array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
          r = m.future();
          return it_should_flush_to(r, [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0]);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=macrocell_unit.test.js.map
